//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { DateTime, Duration } from "luxon";

export interface IMediaClient {
    getRandomMediaItems(count?: number | undefined): Promise<SwaggerResponse<MediaItem[]>>;
    toggleMediaItem(id?: string | undefined, enabled?: boolean | undefined): Promise<SwaggerResponse<MediaItem>>;
    downloadMediaItem(id?: string | undefined, width?: number | undefined, height?: number | undefined, blur?: number | undefined, format?: MediaTransformOptionsFormat | undefined): Promise<SwaggerResponse<StreamContent>>;
}

export class MediaClient implements IMediaClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getRandomMediaItems(count?: number | undefined, signal?: AbortSignal): Promise<SwaggerResponse<MediaItem[]>> {
        let url_ = this.baseUrl + "/Media/GetRandomMediaItems?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRandomMediaItems(_response);
        });
    }

    protected processGetRandomMediaItems(response: AxiosResponse): Promise<SwaggerResponse<MediaItem[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MediaItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SwaggerResponse<MediaItem[]>>(new SwaggerResponse<MediaItem[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<MediaItem[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    toggleMediaItem(id?: string | undefined, enabled?: boolean | undefined, signal?: AbortSignal): Promise<SwaggerResponse<MediaItem>> {
        let url_ = this.baseUrl + "/Media/ToggleMediaItem?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (enabled === null)
            throw new Error("The parameter 'enabled' cannot be null.");
        else if (enabled !== undefined)
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToggleMediaItem(_response);
        });
    }

    protected processToggleMediaItem(response: AxiosResponse): Promise<SwaggerResponse<MediaItem>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = MediaItem.fromJS(resultData202);
            return Promise.resolve<SwaggerResponse<MediaItem>>(new SwaggerResponse<MediaItem>(status, _headers, result202));

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = MediaItem.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<MediaItem>>(new SwaggerResponse(status, _headers, null as any));
    }

    downloadMediaItem(id?: string | undefined, width?: number | undefined, height?: number | undefined, blur?: number | undefined, format?: MediaTransformOptionsFormat | undefined, signal?: AbortSignal): Promise<SwaggerResponse<StreamContent>> {
        let url_ = this.baseUrl + "/Media/DownloadMediaItem?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (width === null)
            throw new Error("The parameter 'width' cannot be null.");
        else if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        if (blur === null)
            throw new Error("The parameter 'blur' cannot be null.");
        else if (blur !== undefined)
            url_ += "blur=" + encodeURIComponent("" + blur) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadMediaItem(_response);
        });
    }

    protected processDownloadMediaItem(response: AxiosResponse): Promise<SwaggerResponse<StreamContent>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StreamContent.fromJS(resultData200);
            return Promise.resolve<SwaggerResponse<StreamContent>>(new SwaggerResponse<StreamContent>(status, _headers, result200));

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = StreamContent.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = StreamContent.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<StreamContent>>(new SwaggerResponse(status, _headers, null as any));
    }
}

export interface IWeatherForecastClient {
    getCurrentForecast(longitude?: number | undefined, latitude?: number | undefined): Promise<SwaggerResponse<WeatherForecast>>;
    getHourlyForecast(longitude?: number | undefined, latitude?: number | undefined): Promise<SwaggerResponse<HourlyForecast[]>>;
    getDailyForecast(longitude?: number | undefined, latitude?: number | undefined): Promise<SwaggerResponse<DailyForecast[]>>;
}

export class WeatherForecastClient implements IWeatherForecastClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getCurrentForecast(longitude?: number | undefined, latitude?: number | undefined, signal?: AbortSignal): Promise<SwaggerResponse<WeatherForecast>> {
        let url_ = this.baseUrl + "/WeatherForecast/GetCurrentForecast?";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentForecast(_response);
        });
    }

    protected processGetCurrentForecast(response: AxiosResponse): Promise<SwaggerResponse<WeatherForecast>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WeatherForecast.fromJS(resultData200);
            return Promise.resolve<SwaggerResponse<WeatherForecast>>(new SwaggerResponse<WeatherForecast>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<WeatherForecast>>(new SwaggerResponse(status, _headers, null as any));
    }

    getHourlyForecast(longitude?: number | undefined, latitude?: number | undefined, signal?: AbortSignal): Promise<SwaggerResponse<HourlyForecast[]>> {
        let url_ = this.baseUrl + "/WeatherForecast/GetHourlyForecast?";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetHourlyForecast(_response);
        });
    }

    protected processGetHourlyForecast(response: AxiosResponse): Promise<SwaggerResponse<HourlyForecast[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HourlyForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SwaggerResponse<HourlyForecast[]>>(new SwaggerResponse<HourlyForecast[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<HourlyForecast[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    getDailyForecast(longitude?: number | undefined, latitude?: number | undefined, signal?: AbortSignal): Promise<SwaggerResponse<DailyForecast[]>> {
        let url_ = this.baseUrl + "/WeatherForecast/GetDailyForecast?";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDailyForecast(_response);
        });
    }

    protected processGetDailyForecast(response: AxiosResponse): Promise<SwaggerResponse<DailyForecast[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DailyForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SwaggerResponse<DailyForecast[]>>(new SwaggerResponse<DailyForecast[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<DailyForecast[]>>(new SwaggerResponse(status, _headers, null as any));
    }
}

export class MediaItem implements IMediaItem {
    id?: string;
    created?: DateTime;
    notes?: string;
    enabled?: boolean;
    location?: MediaItemLocation;

    constructor(data?: IMediaItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.location = data.location && !(<any>data.location).toJSON ? new MediaItemLocation(data.location) : <MediaItemLocation>this.location;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.enabled = _data["enabled"];
            this.location = _data["location"] ? MediaItemLocation.fromJS(_data["location"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MediaItem {
        data = typeof data === 'object' ? data : {};
        let result = new MediaItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toString() : <any>undefined;
        data["notes"] = this.notes;
        data["enabled"] = this.enabled;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMediaItem {
    id?: string;
    created?: DateTime;
    notes?: string;
    enabled?: boolean;
    location?: IMediaItemLocation;
}

export class MediaItemLocation implements IMediaItemLocation {
    name?: string;
    latitude?: number;
    longitude?: number;

    constructor(data?: IMediaItemLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): MediaItemLocation {
        data = typeof data === 'object' ? data : {};
        let result = new MediaItemLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IMediaItemLocation {
    name?: string;
    latitude?: number;
    longitude?: number;
}

export abstract class HttpContent implements IHttpContent {
    headers?: HttpContentHeaders;
    allowDuplex?: boolean;

    constructor(data?: IHttpContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.headers = data.headers && !(<any>data.headers).toJSON ? new HttpContentHeaders(data.headers) : <HttpContentHeaders>this.headers;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.headers = _data["headers"] ? HttpContentHeaders.fromJS(_data["headers"]) : <any>undefined;
            this.allowDuplex = _data["allowDuplex"];
        }
    }

    static fromJS(data: any): HttpContent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'HttpContent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headers"] = this.headers ? this.headers.toJSON() : <any>undefined;
        data["allowDuplex"] = this.allowDuplex;
        return data;
    }
}

export interface IHttpContent {
    headers?: IHttpContentHeaders;
    allowDuplex?: boolean;
}

export class StreamContent extends HttpContent implements IStreamContent {
    allowDuplex?: boolean;

    constructor(data?: IStreamContent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.allowDuplex = _data["allowDuplex"];
        }
    }

    static override fromJS(data: any): StreamContent {
        data = typeof data === 'object' ? data : {};
        let result = new StreamContent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowDuplex"] = this.allowDuplex;
        super.toJSON(data);
        return data;
    }
}

export interface IStreamContent extends IHttpContent {
    allowDuplex?: boolean;
}

export class Anonymous implements IAnonymous {
    allow?: string[];
    contentDisposition?: ContentDispositionHeaderValue | undefined;
    contentEncoding?: string[];
    contentLanguage?: string[];
    contentLength?: number | undefined;
    contentLocation?: string | undefined;
    contentMD5?: string | undefined;
    contentRange?: ContentRangeHeaderValue | undefined;
    contentType?: MediaTypeHeaderValue | undefined;
    expires?: DateTime | undefined;
    lastModified?: DateTime | undefined;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.contentDisposition = data.contentDisposition && !(<any>data.contentDisposition).toJSON ? new ContentDispositionHeaderValue(data.contentDisposition) : <ContentDispositionHeaderValue>this.contentDisposition;
            this.contentRange = data.contentRange && !(<any>data.contentRange).toJSON ? new ContentRangeHeaderValue(data.contentRange) : <ContentRangeHeaderValue>this.contentRange;
            this.contentType = data.contentType && !(<any>data.contentType).toJSON ? new MediaTypeHeaderValue(data.contentType) : <MediaTypeHeaderValue>this.contentType;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allow"])) {
                this.allow = [] as any;
                for (let item of _data["allow"])
                    this.allow!.push(item);
            }
            this.contentDisposition = _data["contentDisposition"] ? ContentDispositionHeaderValue.fromJS(_data["contentDisposition"]) : <any>undefined;
            if (Array.isArray(_data["contentEncoding"])) {
                this.contentEncoding = [] as any;
                for (let item of _data["contentEncoding"])
                    this.contentEncoding!.push(item);
            }
            if (Array.isArray(_data["contentLanguage"])) {
                this.contentLanguage = [] as any;
                for (let item of _data["contentLanguage"])
                    this.contentLanguage!.push(item);
            }
            this.contentLength = _data["contentLength"];
            this.contentLocation = _data["contentLocation"];
            this.contentMD5 = _data["contentMD5"];
            this.contentRange = _data["contentRange"] ? ContentRangeHeaderValue.fromJS(_data["contentRange"]) : <any>undefined;
            this.contentType = _data["contentType"] ? MediaTypeHeaderValue.fromJS(_data["contentType"]) : <any>undefined;
            this.expires = _data["expires"] ? DateTime.fromISO(_data["expires"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? DateTime.fromISO(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allow)) {
            data["allow"] = [];
            for (let item of this.allow)
                data["allow"].push(item);
        }
        data["contentDisposition"] = this.contentDisposition ? this.contentDisposition.toJSON() : <any>undefined;
        if (Array.isArray(this.contentEncoding)) {
            data["contentEncoding"] = [];
            for (let item of this.contentEncoding)
                data["contentEncoding"].push(item);
        }
        if (Array.isArray(this.contentLanguage)) {
            data["contentLanguage"] = [];
            for (let item of this.contentLanguage)
                data["contentLanguage"].push(item);
        }
        data["contentLength"] = this.contentLength;
        data["contentLocation"] = this.contentLocation;
        data["contentMD5"] = this.contentMD5;
        data["contentRange"] = this.contentRange ? this.contentRange.toJSON() : <any>undefined;
        data["contentType"] = this.contentType ? this.contentType.toJSON() : <any>undefined;
        data["expires"] = this.expires ? this.expires.toString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toString() : <any>undefined;
        return data;
    }
}

export interface IAnonymous {
    allow?: string[];
    contentDisposition?: IContentDispositionHeaderValue | undefined;
    contentEncoding?: string[];
    contentLanguage?: string[];
    contentLength?: number | undefined;
    contentLocation?: string | undefined;
    contentMD5?: string | undefined;
    contentRange?: IContentRangeHeaderValue | undefined;
    contentType?: IMediaTypeHeaderValue | undefined;
    expires?: DateTime | undefined;
    lastModified?: DateTime | undefined;
}

export class HttpContentHeaders extends Anonymous implements IHttpContentHeaders {

    [key: string]: any;

    constructor(data?: IHttpContentHeaders) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static override fromJS(data: any): HttpContentHeaders {
        data = typeof data === 'object' ? data : {};
        let result = new HttpContentHeaders();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpContentHeaders extends IAnonymous {

    [key: string]: any;
}

export class ContentDispositionHeaderValue implements IContentDispositionHeaderValue {
    dispositionType?: string;
    parameters?: NameValueHeaderValue[];
    name?: string | undefined;
    fileName?: string | undefined;
    fileNameStar?: string | undefined;
    creationDate?: DateTime | undefined;
    modificationDate?: DateTime | undefined;
    readDate?: DateTime | undefined;
    size?: number | undefined;

    constructor(data?: IContentDispositionHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.parameters) {
                this.parameters = [];
                for (let i = 0; i < data.parameters.length; i++) {
                    let item = data.parameters[i];
                    this.parameters[i] = item && !(<any>item).toJSON ? new NameValueHeaderValue(item) : <NameValueHeaderValue>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispositionType = _data["dispositionType"];
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(NameValueHeaderValue.fromJS(item));
            }
            this.name = _data["name"];
            this.fileName = _data["fileName"];
            this.fileNameStar = _data["fileNameStar"];
            this.creationDate = _data["creationDate"] ? DateTime.fromISO(_data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = _data["modificationDate"] ? DateTime.fromISO(_data["modificationDate"].toString()) : <any>undefined;
            this.readDate = _data["readDate"] ? DateTime.fromISO(_data["readDate"].toString()) : <any>undefined;
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): ContentDispositionHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ContentDispositionHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispositionType"] = this.dispositionType;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        data["fileNameStar"] = this.fileNameStar;
        data["creationDate"] = this.creationDate ? this.creationDate.toString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toString() : <any>undefined;
        data["readDate"] = this.readDate ? this.readDate.toString() : <any>undefined;
        data["size"] = this.size;
        return data;
    }
}

export interface IContentDispositionHeaderValue {
    dispositionType?: string;
    parameters?: INameValueHeaderValue[];
    name?: string | undefined;
    fileName?: string | undefined;
    fileNameStar?: string | undefined;
    creationDate?: DateTime | undefined;
    modificationDate?: DateTime | undefined;
    readDate?: DateTime | undefined;
    size?: number | undefined;
}

export class NameValueHeaderValue implements INameValueHeaderValue {
    name?: string;
    value?: string | undefined;

    constructor(data?: INameValueHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueHeaderValue {
    name?: string;
    value?: string | undefined;
}

export class ContentRangeHeaderValue implements IContentRangeHeaderValue {
    unit?: string;
    from?: number | undefined;
    to?: number | undefined;
    length?: number | undefined;
    hasLength?: boolean;
    hasRange?: boolean;

    constructor(data?: IContentRangeHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unit = _data["unit"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.length = _data["length"];
            this.hasLength = _data["hasLength"];
            this.hasRange = _data["hasRange"];
        }
    }

    static fromJS(data: any): ContentRangeHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new ContentRangeHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unit"] = this.unit;
        data["from"] = this.from;
        data["to"] = this.to;
        data["length"] = this.length;
        data["hasLength"] = this.hasLength;
        data["hasRange"] = this.hasRange;
        return data;
    }
}

export interface IContentRangeHeaderValue {
    unit?: string;
    from?: number | undefined;
    to?: number | undefined;
    length?: number | undefined;
    hasLength?: boolean;
    hasRange?: boolean;
}

export class MediaTypeHeaderValue implements IMediaTypeHeaderValue {
    charSet?: string | undefined;
    parameters?: NameValueHeaderValue[];
    mediaType?: string | undefined;

    constructor(data?: IMediaTypeHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.parameters) {
                this.parameters = [];
                for (let i = 0; i < data.parameters.length; i++) {
                    let item = data.parameters[i];
                    this.parameters[i] = item && !(<any>item).toJSON ? new NameValueHeaderValue(item) : <NameValueHeaderValue>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.charSet = _data["charSet"];
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(NameValueHeaderValue.fromJS(item));
            }
            this.mediaType = _data["mediaType"];
        }
    }

    static fromJS(data: any): MediaTypeHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new MediaTypeHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["charSet"] = this.charSet;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["mediaType"] = this.mediaType;
        return data;
    }
}

export interface IMediaTypeHeaderValue {
    charSet?: string | undefined;
    parameters?: INameValueHeaderValue[];
    mediaType?: string | undefined;
}

export class KeyValuePairOfStringAndIEnumerableOfString implements IKeyValuePairOfStringAndIEnumerableOfString {
    key?: string;
    value?: string[];

    constructor(data?: IKeyValuePairOfStringAndIEnumerableOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): KeyValuePairOfStringAndIEnumerableOfString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringAndIEnumerableOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export interface IKeyValuePairOfStringAndIEnumerableOfString {
    key?: string;
    value?: string[];
}

export enum MediaTransformOptionsFormat {
    Jpeg = "Jpeg",
    WebP = "WebP",
    Avif = "Avif",
}

export class WeatherForecast implements IWeatherForecast {
    feelsLikeTemperature?: number;
    maxTemperature?: number;
    minTemperature?: number;
    chanceOfRain?: number;
    amountOfRain?: number;
    weatherCode?: string;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feelsLikeTemperature = _data["feelsLikeTemperature"];
            this.maxTemperature = _data["maxTemperature"];
            this.minTemperature = _data["minTemperature"];
            this.chanceOfRain = _data["chanceOfRain"];
            this.amountOfRain = _data["amountOfRain"];
            this.weatherCode = _data["weatherCode"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feelsLikeTemperature"] = this.feelsLikeTemperature;
        data["maxTemperature"] = this.maxTemperature;
        data["minTemperature"] = this.minTemperature;
        data["chanceOfRain"] = this.chanceOfRain;
        data["amountOfRain"] = this.amountOfRain;
        data["weatherCode"] = this.weatherCode;
        return data;
    }
}

export interface IWeatherForecast {
    feelsLikeTemperature?: number;
    maxTemperature?: number;
    minTemperature?: number;
    chanceOfRain?: number;
    amountOfRain?: number;
    weatherCode?: string;
}

export class HourlyForecast implements IHourlyForecast {
    time?: DateTime;
    apparentTemperature?: number;
    precipitation?: number;
    precipitationProbability?: number;
    windDirection?: number;
    windSpeed?: number;
    windGusts?: number;
    isDay?: boolean;
    cloudCover?: number;

    constructor(data?: IHourlyForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"] ? DateTime.fromISO(_data["time"].toString()) : <any>undefined;
            this.apparentTemperature = _data["apparentTemperature"];
            this.precipitation = _data["precipitation"];
            this.precipitationProbability = _data["precipitationProbability"];
            this.windDirection = _data["windDirection"];
            this.windSpeed = _data["windSpeed"];
            this.windGusts = _data["windGusts"];
            this.isDay = _data["isDay"];
            this.cloudCover = _data["cloudCover"];
        }
    }

    static fromJS(data: any): HourlyForecast {
        data = typeof data === 'object' ? data : {};
        let result = new HourlyForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toString() : <any>undefined;
        data["apparentTemperature"] = this.apparentTemperature;
        data["precipitation"] = this.precipitation;
        data["precipitationProbability"] = this.precipitationProbability;
        data["windDirection"] = this.windDirection;
        data["windSpeed"] = this.windSpeed;
        data["windGusts"] = this.windGusts;
        data["isDay"] = this.isDay;
        data["cloudCover"] = this.cloudCover;
        return data;
    }
}

export interface IHourlyForecast {
    time?: DateTime;
    apparentTemperature?: number;
    precipitation?: number;
    precipitationProbability?: number;
    windDirection?: number;
    windSpeed?: number;
    windGusts?: number;
    isDay?: boolean;
    cloudCover?: number;
}

export class DailyForecast implements IDailyForecast {
    time?: DateTime;
    apparentTemperatureMin?: number;
    apparentTemperatureMax?: number;
    daylightDuration?: number;
    sunrise?: DateTime;
    sunset?: DateTime;
    uvIndexClearSkyMax?: number;
    uvIndexMax?: number;
    weatherCode?: WmoWeatherCode;
    weatherCodeLabel?: string;
    precipitationSum?: number;
    precipitationProbabilityMax?: number;
    precipitationProbabilityMin?: number;

    constructor(data?: IDailyForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"] ? DateTime.fromISO(_data["time"].toString()) : <any>undefined;
            this.apparentTemperatureMin = _data["apparentTemperatureMin"];
            this.apparentTemperatureMax = _data["apparentTemperatureMax"];
            this.daylightDuration = _data["daylightDuration"];
            this.sunrise = _data["sunrise"] ? DateTime.fromISO(_data["sunrise"].toString()) : <any>undefined;
            this.sunset = _data["sunset"] ? DateTime.fromISO(_data["sunset"].toString()) : <any>undefined;
            this.uvIndexClearSkyMax = _data["uvIndexClearSkyMax"];
            this.uvIndexMax = _data["uvIndexMax"];
            this.weatherCode = _data["weatherCode"];
            this.weatherCodeLabel = _data["weatherCodeLabel"];
            this.precipitationSum = _data["precipitationSum"];
            this.precipitationProbabilityMax = _data["precipitationProbabilityMax"];
            this.precipitationProbabilityMin = _data["precipitationProbabilityMin"];
        }
    }

    static fromJS(data: any): DailyForecast {
        data = typeof data === 'object' ? data : {};
        let result = new DailyForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toFormat('yyyy-MM-dd') : <any>undefined;
        data["apparentTemperatureMin"] = this.apparentTemperatureMin;
        data["apparentTemperatureMax"] = this.apparentTemperatureMax;
        data["daylightDuration"] = this.daylightDuration;
        data["sunrise"] = this.sunrise ? this.sunrise.toString() : <any>undefined;
        data["sunset"] = this.sunset ? this.sunset.toString() : <any>undefined;
        data["uvIndexClearSkyMax"] = this.uvIndexClearSkyMax;
        data["uvIndexMax"] = this.uvIndexMax;
        data["weatherCode"] = this.weatherCode;
        data["weatherCodeLabel"] = this.weatherCodeLabel;
        data["precipitationSum"] = this.precipitationSum;
        data["precipitationProbabilityMax"] = this.precipitationProbabilityMax;
        data["precipitationProbabilityMin"] = this.precipitationProbabilityMin;
        return data;
    }
}

export interface IDailyForecast {
    time?: DateTime;
    apparentTemperatureMin?: number;
    apparentTemperatureMax?: number;
    daylightDuration?: number;
    sunrise?: DateTime;
    sunset?: DateTime;
    uvIndexClearSkyMax?: number;
    uvIndexMax?: number;
    weatherCode?: WmoWeatherCode;
    weatherCodeLabel?: string;
    precipitationSum?: number;
    precipitationProbabilityMax?: number;
    precipitationProbabilityMin?: number;
}

export enum WmoWeatherCode {
    Clear = "Clear",
    MostlyClear = "MostlyClear",
    PartlyClear = "PartlyClear",
    Overcast = "Overcast",
    Fog = "Fog",
    RimeFog = "RimeFog",
    LightDrizzle = "LightDrizzle",
    MediumDrizzle = "MediumDrizzle",
    HeavyDrizzle = "HeavyDrizzle",
    LightFreezingDrizzle = "LightFreezingDrizzle",
    HeavyFreezingDrizzle = "HeavyFreezingDrizzle",
    LightRain = "LightRain",
    MediumRain = "MediumRain",
    HeavyRain = "HeavyRain",
    LightFreezingRain = "LightFreezingRain",
    HeavyFreezingRain = "HeavyFreezingRain",
    LightSnow = "LightSnow",
    MediumSnow = "MediumSnow",
    HeavySnow = "HeavySnow",
    GrainySnow = "GrainySnow",
    LightRainShower = "LightRainShower",
    MediumRainShower = "MediumRainShower",
    HeavyRainShower = "HeavyRainShower",
    LightSnowShower = "LightSnowShower",
    HeavySnowShower = "HeavySnowShower",
    Thunderstorm = "Thunderstorm",
    ThunderstormWithSomeRain = "ThunderstormWithSomeRain",
    ThunderstormWithHeavyRain = "ThunderstormWithHeavyRain",
}

export class SwaggerResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
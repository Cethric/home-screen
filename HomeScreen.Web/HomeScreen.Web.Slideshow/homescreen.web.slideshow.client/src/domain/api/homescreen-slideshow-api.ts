//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { DateTime, Duration } from "luxon";

export interface IMediaClient {
    getRandomMediaItems(count?: number | undefined): Promise<SwaggerResponse<WeatherForecast>>;
    toggleMediaItem(id?: string | undefined, enabled?: boolean | undefined): Promise<SwaggerResponse<WeatherForecast>>;
}

export class MediaClient implements IMediaClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getRandomMediaItems(count?: number | undefined, signal?: AbortSignal): Promise<SwaggerResponse<WeatherForecast>> {
        let url_ = this.baseUrl + "/Media/GetRandomMediaItems?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRandomMediaItems(_response);
        });
    }

    protected processGetRandomMediaItems(response: AxiosResponse): Promise<SwaggerResponse<WeatherForecast>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WeatherForecast.fromJS(resultData200);
            return Promise.resolve<SwaggerResponse<WeatherForecast>>(new SwaggerResponse<WeatherForecast>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<WeatherForecast>>(new SwaggerResponse(status, _headers, null as any));
    }

    toggleMediaItem(id?: string | undefined, enabled?: boolean | undefined, signal?: AbortSignal): Promise<SwaggerResponse<WeatherForecast>> {
        let url_ = this.baseUrl + "/Media/ToggleMediaItem?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (enabled === null)
            throw new Error("The parameter 'enabled' cannot be null.");
        else if (enabled !== undefined)
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToggleMediaItem(_response);
        });
    }

    protected processToggleMediaItem(response: AxiosResponse): Promise<SwaggerResponse<WeatherForecast>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202  = _responseText;
            result202 = WeatherForecast.fromJS(resultData202);
            return Promise.resolve<SwaggerResponse<WeatherForecast>>(new SwaggerResponse<WeatherForecast>(status, _headers, result202));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<WeatherForecast>>(new SwaggerResponse(status, _headers, null as any));
    }
}

export interface IWeatherForecastClient {
    getCurrentForecast(longitude?: number | undefined, latitude?: number | undefined): Promise<SwaggerResponse<WeatherForecast>>;
    getHourlyForecast(longitude?: number | undefined, latitude?: number | undefined): Promise<SwaggerResponse<HourlyForecast[]>>;
    getDailyForecast(longitude?: number | undefined, latitude?: number | undefined): Promise<SwaggerResponse<DailyForecast[]>>;
}

export class WeatherForecastClient implements IWeatherForecastClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getCurrentForecast(longitude?: number | undefined, latitude?: number | undefined, signal?: AbortSignal): Promise<SwaggerResponse<WeatherForecast>> {
        let url_ = this.baseUrl + "/WeatherForecast/GetCurrentForecast?";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentForecast(_response);
        });
    }

    protected processGetCurrentForecast(response: AxiosResponse): Promise<SwaggerResponse<WeatherForecast>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WeatherForecast.fromJS(resultData200);
            return Promise.resolve<SwaggerResponse<WeatherForecast>>(new SwaggerResponse<WeatherForecast>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<WeatherForecast>>(new SwaggerResponse(status, _headers, null as any));
    }

    getHourlyForecast(longitude?: number | undefined, latitude?: number | undefined, signal?: AbortSignal): Promise<SwaggerResponse<HourlyForecast[]>> {
        let url_ = this.baseUrl + "/WeatherForecast/GetHourlyForecast?";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetHourlyForecast(_response);
        });
    }

    protected processGetHourlyForecast(response: AxiosResponse): Promise<SwaggerResponse<HourlyForecast[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HourlyForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SwaggerResponse<HourlyForecast[]>>(new SwaggerResponse<HourlyForecast[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<HourlyForecast[]>>(new SwaggerResponse(status, _headers, null as any));
    }

    getDailyForecast(longitude?: number | undefined, latitude?: number | undefined, signal?: AbortSignal): Promise<SwaggerResponse<DailyForecast[]>> {
        let url_ = this.baseUrl + "/WeatherForecast/GetDailyForecast?";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDailyForecast(_response);
        });
    }

    protected processGetDailyForecast(response: AxiosResponse): Promise<SwaggerResponse<DailyForecast[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DailyForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SwaggerResponse<DailyForecast[]>>(new SwaggerResponse<DailyForecast[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SwaggerResponse<DailyForecast[]>>(new SwaggerResponse(status, _headers, null as any));
    }
}

export class WeatherForecast implements IWeatherForecast {
    feelsLikeTemperature?: number;
    maxTemperature?: number;
    minTemperature?: number;
    chanceOfRain?: number;
    amountOfRain?: number;
    weatherCode?: string;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feelsLikeTemperature = _data["feelsLikeTemperature"];
            this.maxTemperature = _data["maxTemperature"];
            this.minTemperature = _data["minTemperature"];
            this.chanceOfRain = _data["chanceOfRain"];
            this.amountOfRain = _data["amountOfRain"];
            this.weatherCode = _data["weatherCode"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feelsLikeTemperature"] = this.feelsLikeTemperature;
        data["maxTemperature"] = this.maxTemperature;
        data["minTemperature"] = this.minTemperature;
        data["chanceOfRain"] = this.chanceOfRain;
        data["amountOfRain"] = this.amountOfRain;
        data["weatherCode"] = this.weatherCode;
        return data;
    }
}

export interface IWeatherForecast {
    feelsLikeTemperature?: number;
    maxTemperature?: number;
    minTemperature?: number;
    chanceOfRain?: number;
    amountOfRain?: number;
    weatherCode?: string;
}

export class HourlyForecast implements IHourlyForecast {
    time?: DateTime;
    apparentTemperature?: number;
    precipitation?: number;
    precipitationProbability?: number;
    windDirection?: number;
    windSpeed?: number;
    windGusts?: number;
    isDay?: boolean;
    cloudCover?: number;

    constructor(data?: IHourlyForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"] ? DateTime.fromISO(_data["time"].toString()) : <any>undefined;
            this.apparentTemperature = _data["apparentTemperature"];
            this.precipitation = _data["precipitation"];
            this.precipitationProbability = _data["precipitationProbability"];
            this.windDirection = _data["windDirection"];
            this.windSpeed = _data["windSpeed"];
            this.windGusts = _data["windGusts"];
            this.isDay = _data["isDay"];
            this.cloudCover = _data["cloudCover"];
        }
    }

    static fromJS(data: any): HourlyForecast {
        data = typeof data === 'object' ? data : {};
        let result = new HourlyForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toString() : <any>undefined;
        data["apparentTemperature"] = this.apparentTemperature;
        data["precipitation"] = this.precipitation;
        data["precipitationProbability"] = this.precipitationProbability;
        data["windDirection"] = this.windDirection;
        data["windSpeed"] = this.windSpeed;
        data["windGusts"] = this.windGusts;
        data["isDay"] = this.isDay;
        data["cloudCover"] = this.cloudCover;
        return data;
    }
}

export interface IHourlyForecast {
    time?: DateTime;
    apparentTemperature?: number;
    precipitation?: number;
    precipitationProbability?: number;
    windDirection?: number;
    windSpeed?: number;
    windGusts?: number;
    isDay?: boolean;
    cloudCover?: number;
}

export class DailyForecast implements IDailyForecast {
    time?: DateTime;
    apparentTemperatureMin?: number;
    apparentTemperatureMax?: number;
    daylightDuration?: number;
    sunrise?: DateTime;
    sunset?: DateTime;
    uvIndexClearSkyMax?: number;
    uvIndexMax?: number;
    weatherCode?: WmoWeatherCode;
    weatherCodeLabel?: string;
    precipitationSum?: number;
    precipitationProbabilityMax?: number;
    precipitationProbabilityMin?: number;

    constructor(data?: IDailyForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"] ? DateTime.fromISO(_data["time"].toString()) : <any>undefined;
            this.apparentTemperatureMin = _data["apparentTemperatureMin"];
            this.apparentTemperatureMax = _data["apparentTemperatureMax"];
            this.daylightDuration = _data["daylightDuration"];
            this.sunrise = _data["sunrise"] ? DateTime.fromISO(_data["sunrise"].toString()) : <any>undefined;
            this.sunset = _data["sunset"] ? DateTime.fromISO(_data["sunset"].toString()) : <any>undefined;
            this.uvIndexClearSkyMax = _data["uvIndexClearSkyMax"];
            this.uvIndexMax = _data["uvIndexMax"];
            this.weatherCode = _data["weatherCode"];
            this.weatherCodeLabel = _data["weatherCodeLabel"];
            this.precipitationSum = _data["precipitationSum"];
            this.precipitationProbabilityMax = _data["precipitationProbabilityMax"];
            this.precipitationProbabilityMin = _data["precipitationProbabilityMin"];
        }
    }

    static fromJS(data: any): DailyForecast {
        data = typeof data === 'object' ? data : {};
        let result = new DailyForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toFormat('yyyy-MM-dd') : <any>undefined;
        data["apparentTemperatureMin"] = this.apparentTemperatureMin;
        data["apparentTemperatureMax"] = this.apparentTemperatureMax;
        data["daylightDuration"] = this.daylightDuration;
        data["sunrise"] = this.sunrise ? this.sunrise.toString() : <any>undefined;
        data["sunset"] = this.sunset ? this.sunset.toString() : <any>undefined;
        data["uvIndexClearSkyMax"] = this.uvIndexClearSkyMax;
        data["uvIndexMax"] = this.uvIndexMax;
        data["weatherCode"] = this.weatherCode;
        data["weatherCodeLabel"] = this.weatherCodeLabel;
        data["precipitationSum"] = this.precipitationSum;
        data["precipitationProbabilityMax"] = this.precipitationProbabilityMax;
        data["precipitationProbabilityMin"] = this.precipitationProbabilityMin;
        return data;
    }
}

export interface IDailyForecast {
    time?: DateTime;
    apparentTemperatureMin?: number;
    apparentTemperatureMax?: number;
    daylightDuration?: number;
    sunrise?: DateTime;
    sunset?: DateTime;
    uvIndexClearSkyMax?: number;
    uvIndexMax?: number;
    weatherCode?: WmoWeatherCode;
    weatherCodeLabel?: string;
    precipitationSum?: number;
    precipitationProbabilityMax?: number;
    precipitationProbabilityMin?: number;
}

export enum WmoWeatherCode {
    Clear = "Clear",
    MostlyClear = "MostlyClear",
    PartlyClear = "PartlyClear",
    Overcast = "Overcast",
    Fog = "Fog",
    RimeFog = "RimeFog",
    LightDrizzle = "LightDrizzle",
    MediumDrizzle = "MediumDrizzle",
    HeavyDrizzle = "HeavyDrizzle",
    LightFreezingDrizzle = "LightFreezingDrizzle",
    HeavyFreezingDrizzle = "HeavyFreezingDrizzle",
    LightRain = "LightRain",
    MediumRain = "MediumRain",
    HeavyRain = "HeavyRain",
    LightFreezingRain = "LightFreezingRain",
    HeavyFreezingRain = "HeavyFreezingRain",
    LightSnow = "LightSnow",
    MediumSnow = "MediumSnow",
    HeavySnow = "HeavySnow",
    GrainySnow = "GrainySnow",
    LightRainShower = "LightRainShower",
    MediumRainShower = "MediumRainShower",
    HeavyRainShower = "HeavyRainShower",
    LightSnowShower = "LightSnowShower",
    HeavySnowShower = "HeavySnowShower",
    Thunderstorm = "Thunderstorm",
    ThunderstormWithSomeRain = "ThunderstormWithSomeRain",
    ThunderstormWithHeavyRain = "ThunderstormWithHeavyRain",
}

export class SwaggerResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
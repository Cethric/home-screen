//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net.Http;
using HomeScreen.Service.Location.Infrastructure.Location.NominatimLocationService.Generated.Entities;

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace HomeScreen.Service.Location.Infrastructure.Location.NominatimLocationService.Generated.Clients
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NominatimClient : INominatimClient
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public NominatimClient(HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://nominatim.openstreetmap.org";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        public System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reverse Geocoding
        /// </summary>
        /// <remarks>
        /// Reverse geocoding generates an address from a coordinate given as latitude and longitude.
        /// <br/>
        /// <br/># How it works
        /// <br/>
        /// <br/>The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.
        /// <br/>
        /// <br/>First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.
        /// <br/>
        /// <br/>The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street."
        /// </remarks>
        /// <param name="lat">Latitude of a coordinate in WGS84 projection. The API returns exactly one result or an error when the coordinate is in an area with no OSM data coverage.</param>
        /// <param name="lon">Longitude of a coordinate in WGS84 projection. The API returns exactly one result or an error when the coordinate is in an area with no OSM data coverage.</param>
        /// <param name="addressdetails">When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown depends on the output format.</param>
        /// <param name="extratags">When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.</param>
        /// <param name="namedetails">When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.</param>
        /// <param name="accept_language">Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the ["Accept-Language" HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).</param>
        /// <param name="zoom">Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc.</param>
        /// <param name="layer">The layer filter allows to select places by themes.
        /// <br/>
        /// <br/>The `address` layer contains all places that make up an address: address points with house numbers, streets, inhabited places (suburbs, villages, cities, states etc.) and administrative boundaries.
        /// <br/>
        /// <br/>The `poi` layer selects all point of interest. This includes classic points of interest like restaurants, shops, hotels but also less obvious features like recycling bins, guideposts or benches.
        /// <br/>
        /// <br/>The `railway` layer includes railway infrastructure like tracks. Note that in Nominatim's standard configuration, only very few railway features are imported into the database.
        /// <br/>
        /// <br/>The `natural` layer collects features like rivers, lakes and mountains while the manmade layer functions as a catch-all for features not covered by the other layers.</param>
        /// <param name="polygon_geojson">Add the full geometry of the place to the result output. Output formats in GeoJSON, KML, SVG or WKT are supported.</param>
        /// <param name="polygon_kml">Add the full geometry of the place to the result output. Output formats in GeoJSON, KML, SVG or WKT are supported.</param>
        /// <param name="polygon_svg">Add the full geometry of the place to the result output. Output formats in GeoJSON, KML, SVG or WKT are supported.</param>
        /// <param name="polygon_text">Add the full geometry of the place to the result output. Output formats in GeoJSON, KML, SVG or WKT are supported.</param>
        /// <param name="polygon_threshold">When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.</param>
        /// <param name="email">If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim's [Usage Policy](https://operations.osmfoundation.org/policies/nominatim/) for more details.</param>
        /// <param name="debug">Output assorted developer debug information. Data on internals of Nominatim's "search loop" logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.</param>
        /// <returns>Successfully retrieve the current forecast</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SwaggerResponse<ReverseOutputJson>> Reverse_phpAsync(double lat, double lon, OutputFormat? format = null, double? addressdetails = null, double? extratags = null, double? namedetails = null, string? accept_language = null, double? zoom = null, Layer? layer = null, double? polygon_geojson = null, double? polygon_kml = null, double? polygon_svg = null, double? polygon_text = null, float? polygon_threshold = null, string? email = null, double? debug = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (lat == null)
                throw new System.ArgumentNullException("lat");

            if (lon == null)
                throw new System.ArgumentNullException("lon");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "reverse.php"
                    urlBuilder_.Append("reverse.php");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("lat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(lat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("lon")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(lon, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (addressdetails != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("addressdetails")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(addressdetails, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (extratags != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("extratags")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(extratags, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (namedetails != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("namedetails")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(namedetails, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (accept_language != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("accept-language")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(accept_language, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (zoom != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("zoom")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(zoom, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (layer != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("layer")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(layer, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (polygon_geojson != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("polygon_geojson")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(polygon_geojson, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (polygon_kml != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("polygon_kml")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(polygon_kml, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (polygon_svg != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("polygon_svg")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(polygon_svg, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (polygon_text != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("polygon_text")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(polygon_text, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (polygon_threshold != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("polygon_threshold")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(polygon_threshold, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (email != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("email")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(email, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (debug != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("debug")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(debug, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ReverseOutputJson>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return new SwaggerResponse<ReverseOutputJson>(status_, headers_, objectResponse_.Object);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<string>("Anything other than success is an error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T)!, string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody!, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody!, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object? value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
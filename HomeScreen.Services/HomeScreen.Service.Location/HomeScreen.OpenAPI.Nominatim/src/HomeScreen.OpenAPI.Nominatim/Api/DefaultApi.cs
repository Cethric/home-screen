/*
 * Nominatim Open API Spec
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: blake.rogan@outlook.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using HomeScreen.OpenAPI.Nominatim.Client;
using HomeScreen.OpenAPI.Nominatim.Model;

namespace HomeScreen.OpenAPI.Nominatim.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDefaultApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Reverse geocoding generates an address from a coordinate given as latitude and longitude.
        /// </summary>
        /// <remarks>
        /// # How it works The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.  First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.  The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street. 
        /// </remarks>
        /// <exception cref="HomeScreen.OpenAPI.Nominatim.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="lat">Latitude of a coordinate in WGS84 projection</param>
        /// <param name="lon">Longitude of a coordinate in WGS84 projection</param>
        /// <param name="format"> (optional)</param>
        /// <param name="jsonCallback">When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more  information.    Only has an effect for JSON output formats.  (optional)</param>
        /// <param name="addressdetails">When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown  depends on the output format.  (optional)</param>
        /// <param name="extratags">When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.  (optional)</param>
        /// <param name="namedetails">When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.  (optional)</param>
        /// <param name="entrances">When set to 1, include the tagged entrances in the result.  (optional)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the [\&quot;Accept-Language\&quot; HTTP header.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)  (optional, default to &quot;en&quot;)</param>
        /// <param name="zoom">Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc.  (optional)</param>
        /// <param name="layer"> (optional)</param>
        /// <param name="polygonGeojson"> (optional, default to 0M)</param>
        /// <param name="polygonKml"> (optional, default to 0M)</param>
        /// <param name="polygonSvg"> (optional, default to 0M)</param>
        /// <param name="polygonText"> (optional, default to 0M)</param>
        /// <param name="polygonThreshold">When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.  (optional, default to 0F)</param>
        /// <param name="email">If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim&#39;s Usage Policy for more details.  (optional)</param>
        /// <param name="debug">Output assorted developer debug information. Data on internals of Nominatim&#39;s \&quot;search loop\&quot; logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.  (optional, default to 0M)</param>
        /// <returns>ReverseOutputJson</returns>
        ReverseOutputJson ReverseGet(double lat, double lon, OutputFormat? format = default(OutputFormat?), string? jsonCallback = default(string?), NumberBoolean? addressdetails = default(NumberBoolean?), NumberBoolean? extratags = default(NumberBoolean?), NumberBoolean? namedetails = default(NumberBoolean?), NumberBoolean? entrances = default(NumberBoolean?), string? acceptLanguage = default(string?), int? zoom = default(int?), Layer? layer = default(Layer?), decimal? polygonGeojson = default(decimal?), decimal? polygonKml = default(decimal?), decimal? polygonSvg = default(decimal?), decimal? polygonText = default(decimal?), float? polygonThreshold = default(float?), string? email = default(string?), decimal? debug = default(decimal?));

        /// <summary>
        /// Reverse geocoding generates an address from a coordinate given as latitude and longitude.
        /// </summary>
        /// <remarks>
        /// # How it works The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.  First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.  The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street. 
        /// </remarks>
        /// <exception cref="HomeScreen.OpenAPI.Nominatim.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="lat">Latitude of a coordinate in WGS84 projection</param>
        /// <param name="lon">Longitude of a coordinate in WGS84 projection</param>
        /// <param name="format"> (optional)</param>
        /// <param name="jsonCallback">When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more  information.    Only has an effect for JSON output formats.  (optional)</param>
        /// <param name="addressdetails">When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown  depends on the output format.  (optional)</param>
        /// <param name="extratags">When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.  (optional)</param>
        /// <param name="namedetails">When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.  (optional)</param>
        /// <param name="entrances">When set to 1, include the tagged entrances in the result.  (optional)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the [\&quot;Accept-Language\&quot; HTTP header.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)  (optional, default to &quot;en&quot;)</param>
        /// <param name="zoom">Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc.  (optional)</param>
        /// <param name="layer"> (optional)</param>
        /// <param name="polygonGeojson"> (optional, default to 0M)</param>
        /// <param name="polygonKml"> (optional, default to 0M)</param>
        /// <param name="polygonSvg"> (optional, default to 0M)</param>
        /// <param name="polygonText"> (optional, default to 0M)</param>
        /// <param name="polygonThreshold">When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.  (optional, default to 0F)</param>
        /// <param name="email">If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim&#39;s Usage Policy for more details.  (optional)</param>
        /// <param name="debug">Output assorted developer debug information. Data on internals of Nominatim&#39;s \&quot;search loop\&quot; logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.  (optional, default to 0M)</param>
        /// <returns>ApiResponse of ReverseOutputJson</returns>
        ApiResponse<ReverseOutputJson> ReverseGetWithHttpInfo(double lat, double lon, OutputFormat? format = default(OutputFormat?), string? jsonCallback = default(string?), NumberBoolean? addressdetails = default(NumberBoolean?), NumberBoolean? extratags = default(NumberBoolean?), NumberBoolean? namedetails = default(NumberBoolean?), NumberBoolean? entrances = default(NumberBoolean?), string? acceptLanguage = default(string?), int? zoom = default(int?), Layer? layer = default(Layer?), decimal? polygonGeojson = default(decimal?), decimal? polygonKml = default(decimal?), decimal? polygonSvg = default(decimal?), decimal? polygonText = default(decimal?), float? polygonThreshold = default(float?), string? email = default(string?), decimal? debug = default(decimal?));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDefaultApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Reverse geocoding generates an address from a coordinate given as latitude and longitude.
        /// </summary>
        /// <remarks>
        /// # How it works The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.  First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.  The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street. 
        /// </remarks>
        /// <exception cref="HomeScreen.OpenAPI.Nominatim.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="lat">Latitude of a coordinate in WGS84 projection</param>
        /// <param name="lon">Longitude of a coordinate in WGS84 projection</param>
        /// <param name="format"> (optional)</param>
        /// <param name="jsonCallback">When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more  information.    Only has an effect for JSON output formats.  (optional)</param>
        /// <param name="addressdetails">When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown  depends on the output format.  (optional)</param>
        /// <param name="extratags">When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.  (optional)</param>
        /// <param name="namedetails">When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.  (optional)</param>
        /// <param name="entrances">When set to 1, include the tagged entrances in the result.  (optional)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the [\&quot;Accept-Language\&quot; HTTP header.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)  (optional, default to &quot;en&quot;)</param>
        /// <param name="zoom">Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc.  (optional)</param>
        /// <param name="layer"> (optional)</param>
        /// <param name="polygonGeojson"> (optional, default to 0M)</param>
        /// <param name="polygonKml"> (optional, default to 0M)</param>
        /// <param name="polygonSvg"> (optional, default to 0M)</param>
        /// <param name="polygonText"> (optional, default to 0M)</param>
        /// <param name="polygonThreshold">When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.  (optional, default to 0F)</param>
        /// <param name="email">If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim&#39;s Usage Policy for more details.  (optional)</param>
        /// <param name="debug">Output assorted developer debug information. Data on internals of Nominatim&#39;s \&quot;search loop\&quot; logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.  (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReverseOutputJson</returns>
        System.Threading.Tasks.Task<ReverseOutputJson> ReverseGetAsync(double lat, double lon, OutputFormat? format = default(OutputFormat?), string? jsonCallback = default(string?), NumberBoolean? addressdetails = default(NumberBoolean?), NumberBoolean? extratags = default(NumberBoolean?), NumberBoolean? namedetails = default(NumberBoolean?), NumberBoolean? entrances = default(NumberBoolean?), string? acceptLanguage = default(string?), int? zoom = default(int?), Layer? layer = default(Layer?), decimal? polygonGeojson = default(decimal?), decimal? polygonKml = default(decimal?), decimal? polygonSvg = default(decimal?), decimal? polygonText = default(decimal?), float? polygonThreshold = default(float?), string? email = default(string?), decimal? debug = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Reverse geocoding generates an address from a coordinate given as latitude and longitude.
        /// </summary>
        /// <remarks>
        /// # How it works The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.  First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.  The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street. 
        /// </remarks>
        /// <exception cref="HomeScreen.OpenAPI.Nominatim.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="lat">Latitude of a coordinate in WGS84 projection</param>
        /// <param name="lon">Longitude of a coordinate in WGS84 projection</param>
        /// <param name="format"> (optional)</param>
        /// <param name="jsonCallback">When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more  information.    Only has an effect for JSON output formats.  (optional)</param>
        /// <param name="addressdetails">When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown  depends on the output format.  (optional)</param>
        /// <param name="extratags">When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.  (optional)</param>
        /// <param name="namedetails">When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.  (optional)</param>
        /// <param name="entrances">When set to 1, include the tagged entrances in the result.  (optional)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the [\&quot;Accept-Language\&quot; HTTP header.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)  (optional, default to &quot;en&quot;)</param>
        /// <param name="zoom">Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc.  (optional)</param>
        /// <param name="layer"> (optional)</param>
        /// <param name="polygonGeojson"> (optional, default to 0M)</param>
        /// <param name="polygonKml"> (optional, default to 0M)</param>
        /// <param name="polygonSvg"> (optional, default to 0M)</param>
        /// <param name="polygonText"> (optional, default to 0M)</param>
        /// <param name="polygonThreshold">When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.  (optional, default to 0F)</param>
        /// <param name="email">If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim&#39;s Usage Policy for more details.  (optional)</param>
        /// <param name="debug">Output assorted developer debug information. Data on internals of Nominatim&#39;s \&quot;search loop\&quot; logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.  (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReverseOutputJson)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReverseOutputJson>> ReverseGetWithHttpInfoAsync(double lat, double lon, OutputFormat? format = default(OutputFormat?), string? jsonCallback = default(string?), NumberBoolean? addressdetails = default(NumberBoolean?), NumberBoolean? extratags = default(NumberBoolean?), NumberBoolean? namedetails = default(NumberBoolean?), NumberBoolean? entrances = default(NumberBoolean?), string? acceptLanguage = default(string?), int? zoom = default(int?), Layer? layer = default(Layer?), decimal? polygonGeojson = default(decimal?), decimal? polygonKml = default(decimal?), decimal? polygonSvg = default(decimal?), decimal? polygonText = default(decimal?), float? polygonThreshold = default(float?), string? email = default(string?), decimal? debug = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDefaultApi : IDefaultApiSync, IDefaultApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class DefaultApi : IDisposable, IDefaultApi
    {
        private HomeScreen.OpenAPI.Nominatim.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <returns></returns>
        public DefaultApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        public DefaultApi(string basePath)
        {
            this.Configuration = HomeScreen.OpenAPI.Nominatim.Client.Configuration.MergeConfigurations(
                HomeScreen.OpenAPI.Nominatim.Client.GlobalConfiguration.Instance,
                new HomeScreen.OpenAPI.Nominatim.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new HomeScreen.OpenAPI.Nominatim.Client.ApiClient(this.Configuration.BasePath);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = HomeScreen.OpenAPI.Nominatim.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class using Configuration object.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        public DefaultApi(HomeScreen.OpenAPI.Nominatim.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = HomeScreen.OpenAPI.Nominatim.Client.Configuration.MergeConfigurations(
                HomeScreen.OpenAPI.Nominatim.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new HomeScreen.OpenAPI.Nominatim.Client.ApiClient(this.Configuration.BasePath);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = HomeScreen.OpenAPI.Nominatim.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public DefaultApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public DefaultApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException("client");

            this.Configuration = HomeScreen.OpenAPI.Nominatim.Client.Configuration.MergeConfigurations(
                HomeScreen.OpenAPI.Nominatim.Client.GlobalConfiguration.Instance,
                new HomeScreen.OpenAPI.Nominatim.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new HomeScreen.OpenAPI.Nominatim.Client.ApiClient(client, this.Configuration.BasePath, handler);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = HomeScreen.OpenAPI.Nominatim.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public DefaultApi(HttpClient client, HomeScreen.OpenAPI.Nominatim.Client.Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            if (client == null) throw new ArgumentNullException("client");

            this.Configuration = HomeScreen.OpenAPI.Nominatim.Client.Configuration.MergeConfigurations(
                HomeScreen.OpenAPI.Nominatim.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new HomeScreen.OpenAPI.Nominatim.Client.ApiClient(client, this.Configuration.BasePath, handler);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = HomeScreen.OpenAPI.Nominatim.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public DefaultApi(HomeScreen.OpenAPI.Nominatim.Client.ISynchronousClient client, HomeScreen.OpenAPI.Nominatim.Client.IAsynchronousClient asyncClient, HomeScreen.OpenAPI.Nominatim.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = HomeScreen.OpenAPI.Nominatim.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Disposes resources if they were created by us
        /// </summary>
        public void Dispose()
        {
            this.ApiClient?.Dispose();
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public HomeScreen.OpenAPI.Nominatim.Client.ApiClient ApiClient { get; set; } = null;

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public HomeScreen.OpenAPI.Nominatim.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public HomeScreen.OpenAPI.Nominatim.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public HomeScreen.OpenAPI.Nominatim.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public HomeScreen.OpenAPI.Nominatim.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Reverse geocoding generates an address from a coordinate given as latitude and longitude. # How it works The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.  First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.  The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street. 
        /// </summary>
        /// <exception cref="HomeScreen.OpenAPI.Nominatim.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="lat">Latitude of a coordinate in WGS84 projection</param>
        /// <param name="lon">Longitude of a coordinate in WGS84 projection</param>
        /// <param name="format"> (optional)</param>
        /// <param name="jsonCallback">When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more  information.    Only has an effect for JSON output formats.  (optional)</param>
        /// <param name="addressdetails">When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown  depends on the output format.  (optional)</param>
        /// <param name="extratags">When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.  (optional)</param>
        /// <param name="namedetails">When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.  (optional)</param>
        /// <param name="entrances">When set to 1, include the tagged entrances in the result.  (optional)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the [\&quot;Accept-Language\&quot; HTTP header.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)  (optional, default to &quot;en&quot;)</param>
        /// <param name="zoom">Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc.  (optional)</param>
        /// <param name="layer"> (optional)</param>
        /// <param name="polygonGeojson"> (optional, default to 0M)</param>
        /// <param name="polygonKml"> (optional, default to 0M)</param>
        /// <param name="polygonSvg"> (optional, default to 0M)</param>
        /// <param name="polygonText"> (optional, default to 0M)</param>
        /// <param name="polygonThreshold">When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.  (optional, default to 0F)</param>
        /// <param name="email">If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim&#39;s Usage Policy for more details.  (optional)</param>
        /// <param name="debug">Output assorted developer debug information. Data on internals of Nominatim&#39;s \&quot;search loop\&quot; logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.  (optional, default to 0M)</param>
        /// <returns>ReverseOutputJson</returns>
        public ReverseOutputJson ReverseGet(double lat, double lon, OutputFormat? format = default(OutputFormat?), string? jsonCallback = default(string?), NumberBoolean? addressdetails = default(NumberBoolean?), NumberBoolean? extratags = default(NumberBoolean?), NumberBoolean? namedetails = default(NumberBoolean?), NumberBoolean? entrances = default(NumberBoolean?), string? acceptLanguage = default(string?), int? zoom = default(int?), Layer? layer = default(Layer?), decimal? polygonGeojson = default(decimal?), decimal? polygonKml = default(decimal?), decimal? polygonSvg = default(decimal?), decimal? polygonText = default(decimal?), float? polygonThreshold = default(float?), string? email = default(string?), decimal? debug = default(decimal?))
        {
            HomeScreen.OpenAPI.Nominatim.Client.ApiResponse<ReverseOutputJson> localVarResponse = ReverseGetWithHttpInfo(lat, lon, format, jsonCallback, addressdetails, extratags, namedetails, entrances, acceptLanguage, zoom, layer, polygonGeojson, polygonKml, polygonSvg, polygonText, polygonThreshold, email, debug);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reverse geocoding generates an address from a coordinate given as latitude and longitude. # How it works The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.  First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.  The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street. 
        /// </summary>
        /// <exception cref="HomeScreen.OpenAPI.Nominatim.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="lat">Latitude of a coordinate in WGS84 projection</param>
        /// <param name="lon">Longitude of a coordinate in WGS84 projection</param>
        /// <param name="format"> (optional)</param>
        /// <param name="jsonCallback">When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more  information.    Only has an effect for JSON output formats.  (optional)</param>
        /// <param name="addressdetails">When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown  depends on the output format.  (optional)</param>
        /// <param name="extratags">When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.  (optional)</param>
        /// <param name="namedetails">When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.  (optional)</param>
        /// <param name="entrances">When set to 1, include the tagged entrances in the result.  (optional)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the [\&quot;Accept-Language\&quot; HTTP header.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)  (optional, default to &quot;en&quot;)</param>
        /// <param name="zoom">Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc.  (optional)</param>
        /// <param name="layer"> (optional)</param>
        /// <param name="polygonGeojson"> (optional, default to 0M)</param>
        /// <param name="polygonKml"> (optional, default to 0M)</param>
        /// <param name="polygonSvg"> (optional, default to 0M)</param>
        /// <param name="polygonText"> (optional, default to 0M)</param>
        /// <param name="polygonThreshold">When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.  (optional, default to 0F)</param>
        /// <param name="email">If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim&#39;s Usage Policy for more details.  (optional)</param>
        /// <param name="debug">Output assorted developer debug information. Data on internals of Nominatim&#39;s \&quot;search loop\&quot; logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.  (optional, default to 0M)</param>
        /// <returns>ApiResponse of ReverseOutputJson</returns>
        public HomeScreen.OpenAPI.Nominatim.Client.ApiResponse<ReverseOutputJson> ReverseGetWithHttpInfo(double lat, double lon, OutputFormat? format = default(OutputFormat?), string? jsonCallback = default(string?), NumberBoolean? addressdetails = default(NumberBoolean?), NumberBoolean? extratags = default(NumberBoolean?), NumberBoolean? namedetails = default(NumberBoolean?), NumberBoolean? entrances = default(NumberBoolean?), string? acceptLanguage = default(string?), int? zoom = default(int?), Layer? layer = default(Layer?), decimal? polygonGeojson = default(decimal?), decimal? polygonKml = default(decimal?), decimal? polygonSvg = default(decimal?), decimal? polygonText = default(decimal?), float? polygonThreshold = default(float?), string? email = default(string?), decimal? debug = default(decimal?))
        {
            HomeScreen.OpenAPI.Nominatim.Client.RequestOptions localVarRequestOptions = new HomeScreen.OpenAPI.Nominatim.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/xml"
            };

            var localVarContentType = HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "lat", lat));
            localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "lon", lon));
            if (format != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "format", format));
            }
            if (jsonCallback != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "json_callback", jsonCallback));
            }
            if (addressdetails != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "addressdetails", addressdetails));
            }
            if (extratags != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "extratags", extratags));
            }
            if (namedetails != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "namedetails", namedetails));
            }
            if (entrances != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "entrances", entrances));
            }
            if (acceptLanguage != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "accept-language", acceptLanguage));
            }
            if (zoom != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "zoom", zoom));
            }
            if (layer != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "layer", layer));
            }
            if (polygonGeojson != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_geojson", polygonGeojson));
            }
            if (polygonKml != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_kml", polygonKml));
            }
            if (polygonSvg != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_svg", polygonSvg));
            }
            if (polygonText != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_text", polygonText));
            }
            if (polygonThreshold != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_threshold", polygonThreshold));
            }
            if (email != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "email", email));
            }
            if (debug != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "debug", debug));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<ReverseOutputJson>("/reverse", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReverseGet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reverse geocoding generates an address from a coordinate given as latitude and longitude. # How it works The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.  First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.  The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street. 
        /// </summary>
        /// <exception cref="HomeScreen.OpenAPI.Nominatim.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="lat">Latitude of a coordinate in WGS84 projection</param>
        /// <param name="lon">Longitude of a coordinate in WGS84 projection</param>
        /// <param name="format"> (optional)</param>
        /// <param name="jsonCallback">When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more  information.    Only has an effect for JSON output formats.  (optional)</param>
        /// <param name="addressdetails">When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown  depends on the output format.  (optional)</param>
        /// <param name="extratags">When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.  (optional)</param>
        /// <param name="namedetails">When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.  (optional)</param>
        /// <param name="entrances">When set to 1, include the tagged entrances in the result.  (optional)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the [\&quot;Accept-Language\&quot; HTTP header.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)  (optional, default to &quot;en&quot;)</param>
        /// <param name="zoom">Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc.  (optional)</param>
        /// <param name="layer"> (optional)</param>
        /// <param name="polygonGeojson"> (optional, default to 0M)</param>
        /// <param name="polygonKml"> (optional, default to 0M)</param>
        /// <param name="polygonSvg"> (optional, default to 0M)</param>
        /// <param name="polygonText"> (optional, default to 0M)</param>
        /// <param name="polygonThreshold">When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.  (optional, default to 0F)</param>
        /// <param name="email">If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim&#39;s Usage Policy for more details.  (optional)</param>
        /// <param name="debug">Output assorted developer debug information. Data on internals of Nominatim&#39;s \&quot;search loop\&quot; logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.  (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ReverseOutputJson</returns>
        public async System.Threading.Tasks.Task<ReverseOutputJson> ReverseGetAsync(double lat, double lon, OutputFormat? format = default(OutputFormat?), string? jsonCallback = default(string?), NumberBoolean? addressdetails = default(NumberBoolean?), NumberBoolean? extratags = default(NumberBoolean?), NumberBoolean? namedetails = default(NumberBoolean?), NumberBoolean? entrances = default(NumberBoolean?), string? acceptLanguage = default(string?), int? zoom = default(int?), Layer? layer = default(Layer?), decimal? polygonGeojson = default(decimal?), decimal? polygonKml = default(decimal?), decimal? polygonSvg = default(decimal?), decimal? polygonText = default(decimal?), float? polygonThreshold = default(float?), string? email = default(string?), decimal? debug = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HomeScreen.OpenAPI.Nominatim.Client.ApiResponse<ReverseOutputJson> localVarResponse = await ReverseGetWithHttpInfoAsync(lat, lon, format, jsonCallback, addressdetails, extratags, namedetails, entrances, acceptLanguage, zoom, layer, polygonGeojson, polygonKml, polygonSvg, polygonText, polygonThreshold, email, debug, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reverse geocoding generates an address from a coordinate given as latitude and longitude. # How it works The reverse geocoding API does not exactly compute the address for the coordinate it receives. It works by finding the closest suitable OSM object and returning its address information. This may occasionally lead to unexpected results.  First of all, Nominatim only includes OSM objects in its index that are suitable for searching. Small, unnamed paths for example are missing from the database and can therefore not be used for reverse geocoding either.  The other issue to be aware of is that the closest OSM object may not always have a similar enough address to the coordinate you were requesting. For example, in dense city areas it may belong to a completely different street. 
        /// </summary>
        /// <exception cref="HomeScreen.OpenAPI.Nominatim.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="lat">Latitude of a coordinate in WGS84 projection</param>
        /// <param name="lon">Longitude of a coordinate in WGS84 projection</param>
        /// <param name="format"> (optional)</param>
        /// <param name="jsonCallback">When given, then JSON output will be wrapped in a callback function with the given name. See JSONP for more  information.    Only has an effect for JSON output formats.  (optional)</param>
        /// <param name="addressdetails">When set to 1, include a breakdown of the address into elements. The exact content of the address breakdown  depends on the output format.  (optional)</param>
        /// <param name="extratags">When set to 1, the response include any additional information in the result that is available in the database, e.g. wikipedia link, opening hours.  (optional)</param>
        /// <param name="namedetails">When set to 1, include a full list of names for the result. These may include language variants, older names, references and brand.  (optional)</param>
        /// <param name="entrances">When set to 1, include the tagged entrances in the result.  (optional)</param>
        /// <param name="acceptLanguage">Preferred language order for showing search results. This may either be a simple comma-separated list of language codes or have the same format as the [\&quot;Accept-Language\&quot; HTTP header.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)  (optional, default to &quot;en&quot;)</param>
        /// <param name="zoom">Level of detail required for the address. This is a number that corresponds roughly to the zoom level used in XYZ tile sources in frameworks like Leaflet.js, Openlayers etc.  (optional)</param>
        /// <param name="layer"> (optional)</param>
        /// <param name="polygonGeojson"> (optional, default to 0M)</param>
        /// <param name="polygonKml"> (optional, default to 0M)</param>
        /// <param name="polygonSvg"> (optional, default to 0M)</param>
        /// <param name="polygonText"> (optional, default to 0M)</param>
        /// <param name="polygonThreshold">When one of the polygon_* outputs is chosen, return a simplified version of the output geometry. The parameter describes the tolerance in degrees with which the geometry may differ from the original geometry. Topology is preserved in the geometry.  (optional, default to 0F)</param>
        /// <param name="email">If you are making large numbers of request please include an appropriate email address to identify your requests. See Nominatim&#39;s Usage Policy for more details.  (optional)</param>
        /// <param name="debug">Output assorted developer debug information. Data on internals of Nominatim&#39;s \&quot;search loop\&quot; logic, and SQL queries. The output is HTML format. This overrides the specified machine readable format.  (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ReverseOutputJson)</returns>
        public async System.Threading.Tasks.Task<HomeScreen.OpenAPI.Nominatim.Client.ApiResponse<ReverseOutputJson>> ReverseGetWithHttpInfoAsync(double lat, double lon, OutputFormat? format = default(OutputFormat?), string? jsonCallback = default(string?), NumberBoolean? addressdetails = default(NumberBoolean?), NumberBoolean? extratags = default(NumberBoolean?), NumberBoolean? namedetails = default(NumberBoolean?), NumberBoolean? entrances = default(NumberBoolean?), string? acceptLanguage = default(string?), int? zoom = default(int?), Layer? layer = default(Layer?), decimal? polygonGeojson = default(decimal?), decimal? polygonKml = default(decimal?), decimal? polygonSvg = default(decimal?), decimal? polygonText = default(decimal?), float? polygonThreshold = default(float?), string? email = default(string?), decimal? debug = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            HomeScreen.OpenAPI.Nominatim.Client.RequestOptions localVarRequestOptions = new HomeScreen.OpenAPI.Nominatim.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/xml"
            };


            var localVarContentType = HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "lat", lat));
            localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "lon", lon));
            if (format != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "format", format));
            }
            if (jsonCallback != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "json_callback", jsonCallback));
            }
            if (addressdetails != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "addressdetails", addressdetails));
            }
            if (extratags != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "extratags", extratags));
            }
            if (namedetails != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "namedetails", namedetails));
            }
            if (entrances != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "entrances", entrances));
            }
            if (acceptLanguage != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "accept-language", acceptLanguage));
            }
            if (zoom != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "zoom", zoom));
            }
            if (layer != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "layer", layer));
            }
            if (polygonGeojson != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_geojson", polygonGeojson));
            }
            if (polygonKml != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_kml", polygonKml));
            }
            if (polygonSvg != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_svg", polygonSvg));
            }
            if (polygonText != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_text", polygonText));
            }
            if (polygonThreshold != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "polygon_threshold", polygonThreshold));
            }
            if (email != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "email", email));
            }
            if (debug != null)
            {
                localVarRequestOptions.QueryParameters.Add(HomeScreen.OpenAPI.Nominatim.Client.ClientUtils.ParameterToMultiMap("", "debug", debug));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ReverseOutputJson>("/reverse", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ReverseGet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
